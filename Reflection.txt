Reflection of King Arthur and Knights similator 

Lu Wang 
1054195

This system is a concurrent simulator which is about Knights sharing their adventure with other knights and King Arthur and is implemented by Java Language. The program can show the trace of events and continue to run if not stopped manually. I will describe this system through implementation, critical design and evaluation.

In this system, there are seven threads running simultaneously, including King Arthur thread, four knight threads, producer thread, and consumer thread. King Arthur thread manages the meeting through functions in Hall class, he will wait until all knights entering the Great Hall sit down, and then meeting begins, and only all knights acquire new quests and stand up from the Round Table can meeting end, then he can leave the Great Hall. For knight threads, they can only enter the Great Hall when King Arthur hasn’t entered, and they can sit around the Round Table after entering the Great Hall. They can acquire new quest after they release their completed quest during the meeting, and then stand up from the Round Table. After meeting ends and King exits the Great Hall, knights will leave to complete their adventure. Therefore, in the knight class, there are some variables for every knight’s status, such as variable ‘enteredHall’ which is to show whether the knight enters the Great hall, the same as variable ‘sitDown’, and variable ‘quest’ which is the acquired quest, after being released, it will be null. Producer thread can add new agenda quests when the number of the new quests is not greater than the number of knights, otherwise, it must wait. Similarly, the consumer thread can remove the completed quests when the number of the quests is not zero. The Agenda Class is to manage all quests in the new agenda and complete agenda. The Hall class is to manage the process of events. Both Agenda and Hall manage the critical resources of this system.

The critical resources in this system are agendas and numbers of knights entering the Great Hall as well as numbers of knights sitting down at the Round Table. Functions of accessing critical resources and variables are modified by ‘synchronized’, and threads must wait before other threads finish their tasks. The number of knights who enter the Great Hall and the number of sitting down knights are modified by ’volatile’ because all knights thread should increment or decrement based on the current value of those numbers.

This system can run smoothly and keep printing the trace of events if not interrupted manually, and seven threads can interact with others well. Through this practice of using monitors in Java, I think the critical resources are the essential issues of thread concurrency, and sometimes, the sleeping time may impact the running order of threads, which can cause mistakes in the event trace.  Additionally, knowing the uncritical resources are also very important to organize the structure of the class, for example, I define a quest for each knight to save their own acquired quest, and after this quest completed and released, it will become null to prepare for next acquiring event.